# 深入生命周期

https://www.vgter.net/archives/4526

## 生命周期省略规则

在`Rust`中，生命周期省略规则用于简化代码，不需要显示的声明生命周期。对于普通函数，`Rust`提供了3条默认的生命周期推断规则，它们可以帮助编译器推断函数签名中的生命周期，而不需要手动指定

1. 每个输入参数的生命周期都可以隐时地与其函数签名相关联
2. 如果函数有一个返回值，且只有一个输入引用参数，那么返回值的生命周期会被推断为与输入参数的生命周期相同
3. 如果函数有多个输入引用参数，并且其中一个时`self`，则返回值的生命周期会与`self`的生命周期相关联、

如下例

```rust
fn fn_elision(x: &i32) -> &i32 { x }
```

会被`Rust`自动推断为

```rust
fn fn_elision<'a>(x: &'a i32) -> &'a i32 { x }
```

为什么这样推断

- `x`的类型时`&i32`，它的生命周期时`'a`
- 函数的返回值类型时`&i32`，没有额外的输入引用，所以`Rust`会假设返回值的生命周期与输入参数`x`相同

### 闭包

对于闭包，`Rust`会根据使用闭包的环境来推断其生命周期。闭包的生命周期是由闭包本身的参数和返回值的生命周期决定的，而不是像函数那样严格按照省略规则推断

闭包的参数生命周期推断有以下几个关键点

1. 闭包的参数生命周期
   - 闭包的参数生命周期会由函数的类型决定。闭包的生命周期推断通常与函数类似，但闭包的生命周期时根据它的上下文来决定的
2. 闭包的返回值生命周期
   - 如果闭包返回一个引用，`Rust`会推断返回值的生命周期为与参数相同的生命周期，或者根据闭包捕获的环境来推断
3. 闭包捕获环境
   - 闭包可以捕获它外部作用域中的变量。`Rust`会根据闭包如何捕获这些变量来决定生命周期
     - 按值捕获：如果闭包按值捕获外部变量（即`move`闭包），则这些变量的生命周期由闭包的生命周期来决定
     - 按引用捕获：如果闭包按引用捕获外部变量，则引用的生命周期必须与闭包的生命周期相适应

### 几个例子

1. 普通闭包

```rust
let closure = |x: &i32| -> &i332 { x }
```

这里，`x`是一个`&i32`类型的引用，闭包返回一个`&i32`类型的引用。`Rust`会推断出生命周期：

```rust
let closure = |x: &'a i32| -> &'a i32 { x }
```

其中，`'a`时推断出来的生命周期，意味着闭包的输入和输出引用共享相同的生命周期。这个生命周期通常由闭包使用时的上下文（例如闭包被调用时的入参）来决定

2. 闭包捕获环境中的变量

考虑闭包捕获外部变量的例子：

```rust
let y = 10;
let closure = |x: &i32| -> &i32 {
    if x > &y {
        &y
    }else {
        x
    }
}
```

这里，闭包捕获了外部变量`y`，并返回一个`&i32`类型的引用。Rust会根据`y`和`x`的生命周期推断出闭包的生命周期。由于`y`是一个局部变量，它的生命周期只会在闭包被调用时才有效，因此Rust会确保返回的引用在闭包的生命周期内是有效的

3. `move`闭包

如果闭包使用`move`关键字捕获变量，闭包会拥有这些变量的所有权，而不是借用它们。这意味着闭包的生命周期和它捕获的变量的生命周期没有直接关系

```rust
let y = 10;
let closure = move |x: &i32| -> i32 {
    x + y
}
```

上面的例子中，闭包通过`move`捕获了`y`的所有权，而不是借用它。`y`的生命周期与闭包的生命周期无关，因为闭包不再借用`y`，而是将`y`移入闭包中，闭包在自己的生命周期内拥有它。

4. 闭包的生命周期推断与函数类似

闭包的生命周期推断通常遵循和普通函数类似的规则。

```rust
fn call_closure<'a>(closure: &'a dyn Fn(&i32) -> &i32) -> &'a i32 {
    let x = 5;
    closure(&x)
}
```

这里，`closure`是一个接受`&i32`类型引用并返回`&i32`类型引用的闭包。Rust会根据`call_closure`的生命周期参数`'a`来推断闭包的生命周期，这样就保证了返回的引用和输入的引用生命周期一致

## &'static 和 T: 'static

### &'static

`&'static`表示一个引用，生命周期为`'static`，即该引用指向的数据在程序的整个生命周期内都是有效的

使用场景

- _静态数据_：指向静态变量或字符串字面量的引用
- _永久有效的引用_：引用一些在程序执行期间始终存在的数据

```rust
static HELLO: &str = "Hello, world!"; // 静态变量，生命周期是 'static

fn main() {
    let s: &'static str = "Hello, world!"; // 字符串字面量，生命周期是 'static
    println!("{}", s);
}

```

在上面的例子中，`s`是一个`&'static str`类型的引用，指向字面量`"Hello, world!"`。字面量具有`'static`生命周期，意味着它会在整个程序的生命周期内都有效

### T: 'static

`T: 'static`是一种泛型约束，用来表示类型`T`必须具有`'static`生命周期，即类型`T`包含的引用或数据的生命周期必须持续整个程序的生命周期

使用场景

- _泛型类型约束_：当你定义泛型函数或结构体时，可以使用`T: 'static`来要求传入的类型包含`'static`生命周期的数据
- _确保数据的长期有效性_：确保类型`T`在程序的整个生命周期内都有效，通常用于跨线程的数据共享或确保引用数据永远不会过期

```rust
fn accept_static<T: 'static>(data: T) {
    // 这里的 T 必须是一个包含 'static 生命周期的类型
    println!("{:?}", data);
}

fn main() {
    accept_static("Hello, world!"); // 字符串字面量有 'static 生命周期
    // accept_static(String::from("Hello")); // 这会报错，因为 String 不是 'static
}

```

在这个例子中，`T: 'static`限制了泛型参数`T`必须具有`'static`生命周期。具体来说，只有那些包含`'static`生命周期的类型才可以传递给`accept_static`函数。例如，字符串字面量`"Hello, world!"`是一个`'static`类型，因此可以传递给函数

但是，`String`类型的实例通常没有`'static`生命周期，除非它时显示的定义为`'static`（例如存储在全局常量中）。因此，如果传递了一个`String`实例，Rust会报错，指出它的生命周期不是`static`

_总结_

- &'static 是一种引用类型，表示引用的生命周期为整个程序的运行期，即 'static。
- T: 'static 是泛型约束，表示泛型类型 T 包含的数据必须在程序的整个生命周期内有效。
- &'static 常用于表示静态数据（如字符串字面量、全局常量、静态变量等），而 T: 'static 常用于多线程或需要跨越较长时间的数据共享场景。
