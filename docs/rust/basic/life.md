# 生命周期

`Rust`的生命周期是其内存管理系统的一部分，目的是确保内存安全而不需要垃圾回收器。生命周期用于描述引用的有效范围，确保在程序运行时引用指向有效的内存地址，避免出现悬空引用和数据竞争等错误

在`Rust`中，生命周期由编译器静态推断，大部分情况下开发者不需要手动显示声明声明周期，但理解它的基本概念是学习`Rust`的一个重要部分。

## 什么是生命周期

生命周期是`Rust`编译器用来跟踪每个引用（`&T`）的有效范围的方式。`Rust`编译器确保在程序运行时，任何引用都不能指向无效内存，从而避免了`悬空引用`和`内存泄漏`

- 悬空引用：指向已释放内存的引用
- 内存泄漏：指分配的内存未被正确释放

总体来说，为了确保每一个引用都是有意义的

## 生命周期的基本规则

1. 每个引用都有一个生命周期
2. 引用必须始终指向有效的数据
3. 编译器会通过生命周期推断来确引用在其生命周期内有效，不会出现悬空引用

## 生命周期的标注

`Rust`使用生命周期标注来显示的指定引用的生命周期。当一个函数接受或返回引用时，生命周期标注告诉编译器引用的生命周期是如何传递的。

生命周期标注的语法是：`'a`，`'a`是生命周期的名称。生命周期标注一般出现在函数签名中

```rust
fn example<'a>(x: &'a str) -> &'a str{
    x
}
```

- `x: &'a str` 表示x是一个生命周期为`'a`的引用，类型为`str`
- `-> &'a str` 表示返回一个生命周期为`'a`的引用，类型为`str`
- `<'a>` 为函数的生命周期生命
- `'a` 就是生命周期标注，告诉编译器`x`的返回的引用有相同的生命周期

## 为什么需要生命周期标注

生命周期标注用于告诉`Rust`编译器，哪些引用的生命周期是相同的，哪些是不同的。如下，编译器无法推断`y`和`x`的生命周期直接的关系，如果x或者y的生命周期比这个函数的生命周期还短，就会返回一个`空指针`，又或者x和y不对等就会从一个空指针处取值，都会造成异常

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

使用生命周期标注后就可以正常运行

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 生命周期和结构体

结构体中也有这个概念，在一定情况下也需要进行生命周期标注，告诉`Rust`该引用的生命周期与结构体实例的生命周期之间的关系：只要为结构体中的`每一个引用标注上生命周期即可`。

```rust
struct Book<'a>{
    title: &'a str,
    author: &'a str
}
```

## 静态生命周期

在`Rust`中，静态生命周期（`'static`）是一个特殊的生命周期，它表示一个引用的有效范围跨越整个程序的生命周期，即从程序的开始到程序结束。静态生命周期的引用通常用于表示程序的常量数据或全局数据

特点：

1. 全局有效性：`'static`生命周期的引用时全局有效的，从程序开始到结束
2. 常量和静态变量： `Rust`中的常量（`const`）和静态变量（`static`）总是具有`'static`生命周期
3. 内存分配：具有`'static`生命周期的引用通常指向程序的常量池或全局数据区域，不会随函数或作用域的结束而释放

下面的字符切片`s`将会在程序的整个生命周期内都是有效的

```rust
fn main() {
    let s: &'static str = "Hello, Rust!";
    println!("{}", s);
}
```
