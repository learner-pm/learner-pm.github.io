import{_ as e,c as o,o as a,a4 as t}from"./chunks/framework.C9smGHvE.js";const u=JSON.parse('{"title":"模块化","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/basic/ecmaScript/module.md","filePath":"frontEnd/basic/ecmaScript/module.md","lastUpdated":1713348121000}'),c={name:"frontEnd/basic/ecmaScript/module.md"},r=t('<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h1><p>es6 的<code>Module</code>使得 JavaScript 具有自己的模块体系。和面向对象语言的封装更接近。</p><h2 id="浏览器模块化" tabindex="-1">浏览器模块化 <a class="header-anchor" href="#浏览器模块化" aria-label="Permalink to &quot;浏览器模块化&quot;">​</a></h2><p>es6 的模块化会自动采用严格模式。<code>export</code>导出，<code>import</code>导入。ES2020 提案 引入 <code>import()</code>函数，支持动态加载模块。</p><p>和 node.js 的 CommonJS 的区别：</p><ul><li>CommonJS 模块输出值的拷贝，es6 模块是值得引用</li><li>CommonJS 模块是运行时加载，es6 模块时编译时输出</li><li>CommonJS 时同步加载(本地加载，性能影响不大)，es6 是异步加载</li></ul>',6),d=[r];function i(n,s,l,m,_,p){return a(),o("div",null,d)}const S=e(c,[["render",i]]);export{u as __pageData,S as default};
