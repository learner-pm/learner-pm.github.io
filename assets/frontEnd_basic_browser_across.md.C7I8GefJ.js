import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.C9smGHvE.js";const t="/assets/three_01.ChD7KAoy.png",n="/assets/three_03.BMtZp6rd.png",p="/assets/three_02.kSeD9BiM.png",C=JSON.parse('{"title":"跨域","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/basic/browser/across.md","filePath":"frontEnd/basic/browser/across.md","lastUpdated":1713260892000}'),l={name:"frontEnd/basic/browser/across.md"},o=e(`<h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h1><p>由于浏览器的同源策略，不允许一个域上的脚本访问另外一个域的文档。同源指协议、域名、端口都相同，如果有一个不同，那么进行访问就会报错，ajax 请求失败。</p><p>Chrome 和 Firefox 不允许从 HTTPS 跨域访问 HTTP。</p><h2 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;JSONP&quot;">​</a></h2><p>可以通过<code>jsonp</code>来解决跨域问题，不过 jsonp 只针对 GET 请求有用。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://api.pmthank.cn/#/?id=a&amp;name=b&amp;callback=getData&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-label="Permalink to &quot;CORS&quot;">​</a></h2><p><code>CORS</code>为 W3c 一个标准，全称为<code>跨域资源共享</code>，它允许浏览器跨域的去向服务器发出<code>XMLHttpRequest</code>请求。</p><p><code>CORS</code>需要浏览器和服务器同时支持，在通信过程中，浏览器会自动的完成这个支持（自动在 ajxa 中添加一些信息）。关键在于后端时候支持。</p><h3 id="请求类型" tabindex="-1">请求类型 <a class="header-anchor" href="#请求类型" aria-label="Permalink to &quot;请求类型&quot;">​</a></h3><p><code>CORS</code>请求分为<strong>简单请求</strong>和<strong>非简单请求</strong></p><p>简单请求需要满足以下要求：</p><ul><li>请求方法为 HEAD、GET、POST</li><li>HTTP 的头信息不超出这些字段 Accept、Accept-Language、Content-Language、Last-Event-Id、Content-Type</li></ul><p>不满足以上情况的都属于非简单请求</p><h4 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-label="Permalink to &quot;简单请求&quot;">​</a></h4><p>浏览器发现这次请求是简单请求后，浏览器就会在头信息中增加<code>Origin</code>字段</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ajax </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./_ajax.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> api</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://127.0.0.1:8800/user/login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> post</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ajax.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(api, {});</span></span></code></pre></div><img src="`+t+'" width="100%"><p>这个<code>Orgin</code>字段用来告诉后端这个请求的<code>源</code>，来判断这个请求是否在服务器的许可<code>源</code>范围。不在则放回一个不包含<code>Access-Control-Allow-Origin</code>字段的头信息，从而被<code>onerror</code>捕获进而报 错。</p><p>后端设置只允许<code>http://localhost:8888</code>访问</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CrossOrigin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">origins</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://localhost:8888&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>前端报错如下</p><img src="'+n+'" width="100%"><p>如果存在返回就如下所示，<code>Response Headers</code> 包含字段<code>Access-Control-Allow-Origin</code>，这个字段用来表示接受那些<code>域名</code>的请求，这里我用<code>spring</code>启动了一个服务器，后端设置<code>*</code>来表示接受任意域名请求。</p><img src="'+p+'" width="100%"><p>还有其他字段如：<code>Access-Control-Allow-Credentials</code>字段表示是否允许发送<code>Cookie</code>，默认不被包含在请求中，设置为<code>true</code>允许<a href="/frontEnd/basic/browser/storage.html">跨域发送 Cookie</a>。</p><p><code>Access-Control-Expose-Headers</code>字段解除<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法的限制。<code>getResponseHeader()</code>默认可拿到字段：</p><ul><li>Cache-Control</li><li>Content-Language</li><li>Content-Type</li><li>Expire</li><li>Last-Mondified</li><li>Pragma</li></ul><h4 id="非简单请求" tabindex="-1">非简单请求 <a class="header-anchor" href="#非简单请求" aria-label="Permalink to &quot;非简单请求&quot;">​</a></h4><p>非简单请求会在通信前增加一次请求（<code>预检</code>）来确定当前域名是否存在于服务器的源名单中，以及可用的 HTTP 动词和头信息字段。</p><p><code>预检</code>头信息包含字段：<code>Access-Control-Request-Method</code>字段表示浏览器用到得请求方法。<code>Access-Control-Request-Headers</code>字段罗列额外发送的头信息字段。</p><p>服务器不通过<code>预检</code>就会报错，通过即后面的请求就会和简单请求一样。</p>',32),h=[o];function d(r,c,k,E,g,y){return a(),i("div",null,h)}const _=s(l,[["render",d]]);export{C as __pageData,_ as default};
