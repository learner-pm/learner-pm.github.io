import{_ as a,c as e,o as l,a4 as i}from"./chunks/framework.C9smGHvE.js";const u=JSON.parse('{"title":"渲染","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/basic/browser/draw.md","filePath":"frontEnd/basic/browser/draw.md","lastUpdated":1713521435000}'),o={name:"frontEnd/basic/browser/draw.md"},t=i('<h1 id="渲染" tabindex="-1">渲染 <a class="header-anchor" href="#渲染" aria-label="Permalink to &quot;渲染&quot;">​</a></h1><p>了解浏览器构建页面过程有助于得到更好得页面效果。</p><h2 id="页面" tabindex="-1">页面 <a class="header-anchor" href="#页面" aria-label="Permalink to &quot;页面&quot;">​</a></h2><p>当请求响应得到数据时。浏览器一般做如下处理工作：</p><ol><li>解析 html 文件，html 元素被解析构建 DOM 树</li><li>解析 css 元素，构建 CSSOM 树</li><li>把 DOM 树和 CSSOM 树合在一起生成渲染树（Render Tree）</li><li>根据渲染树布局</li><li>调用 GPU 绘制图层，显示在屏幕上</li></ol><p>构建过程中，遇到<code>script</code>标签时，会暂停构建，所以在对首屏渲染有速度要求得项目中，尽量减少首批加载 js。</p><p>渲染树会结和 DOM 树和 CSSOM 树，也就是说会结合 html 和 css 来渲染，这个过程中浏览器会去遍历整颗渲染数树，通过 css 计算元素位置，再进行绘制，继而显示。这个过程中，生成或改变 DOM 元素布局等就是<code>回流</code>，计算元素几何信息（外观）等就是<code>重绘</code>。从这里也可以看出二者得关系：回流一定会触发重绘，而重绘不一定会回流。</p><h2 id="回流" tabindex="-1">回流 <a class="header-anchor" href="#回流" aria-label="Permalink to &quot;回流&quot;">​</a></h2><p>常见触发回流操作：</p><ul><li>页面首次渲染</li><li>改变 DOM 元素本身及其相关信息</li><li>改变浏览器窗口尺寸</li><li>css 伪类</li><li>dom 操作方法</li></ul><h2 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h2><p>常见触发重绘操作：</p><ul><li>修改 css 属性 如：color 等</li><li>dom 操作修改</li></ul><p>回流得代价是大于重绘。频繁得回流会导致界面迟缓卡顿，用户体验不好。为此应该尽量减少回流和重绘。</p><ul><li>尽量不适应<code>table</code>布局，<code>table</code>很容易引起回流</li><li>修改样式应该统一修改</li><li>批量做 dom 操作</li><li>使用 css3 属性如：transform，opacity 等代替 对 top 等属性改变得操作</li><li>不隔级操作</li></ul>',15),r=[t];function s(c,d,n,h,p,_){return l(),e("div",null,r)}const b=a(o,[["render",s]]);export{u as __pageData,b as default};
